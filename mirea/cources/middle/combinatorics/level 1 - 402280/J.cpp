#include <bits/stdc++.h>
#define all(x) (x).begin(),(x).end()
#define isz(x) (int)(x).size()
#define int int64_t

// быстрое возведение в степень:
int binpow(int a, int n, int mod) {
    int res = 1 % mod;
    while (n > 0) {
        if (n % 2 == 1)
            res = res * a % mod;
        a = a * a % mod;
        n >>= 1;
    }
    return res;
}

// Комбинаторика: факториалы, обратные к ним и биномиальные коэффициенты
const int mod = (int)1e9+7, NMAX = (int)1e6+30;

int fact[NMAX], ifact[NMAX];

const int precalculated = [](){
    // считаем факториалы:
    fact[0] = 1;
    for (int i = 1; i < NMAX; i++)
        fact[i] = fact[i-1] * i % mod;
    // считаем обратные факториалы:
    ifact[NMAX-1] = binpow(fact[NMAX-1], mod-2, mod);
    for (int i = NMAX-2; i >= 0; i--) {
        ifact[i] = ifact[i+1] * (i+1) % mod;
    }
    return true;
}();

int32_t main() {
    std::ios::sync_with_stdio(false);
    std::cin.tie(0);
    // массив из лампочек будет иметь вид 000010001001001000010000
    // `отрезок` = нули подряд
    // самый левый и самый правый отрезок из нулей можно включить единственным способом
    // каждый из остальных отрезков можно включить 2^(len-1) способами (len = длина отрезка):
    // каждый раз включаем либо самый левый, либо самый правый - два варианта на одно
    // включение, всего включений = len-1, так как последний вариант включения - уникален
    // и единственный: включаем одну оставшуюся лампочку
    
    // Каждый раз мы можем выбирать, какой отрезок включать. Присвоим каждому отрезку
    // свою букву. Пусть у нас 6 отрезков (как в примере выше)
    // [0000]1[000]1[00]1[00]1[0000]1[0000]
    // Отрезок X = [0000] из 4х нулей
    // Отрезок A = [000] из 3х нулей
    // Отрезок B = [00] из 2х нулей
    // Отрезок C = [00] из 2х нулей
    // Отрезок D = [0000] из 4х нулей
    // Отрезок Y = [0000] из 4х нулей
    // Всего должны включить 19 лампочек. Последовательность включений будет
    // AAABBCCDDDDXXXXYYYY - число слов длины 19, состоящих из 3 A, 2 B, 2 C, 4 D, ...
    // Каждое включение может быть слева или справа - домножить на степень двойки
    // Ответ: (n! / (na! * nb! * nc! * ...) * 2^(na-1) * 2^(nb-1) * ...
    // Крайние отрезки учитываем отдельно
    
    // читаем исходные данные:
    int nCells, nTurnedOn;
    std::cin >> nCells >> nTurnedOn;
    std::vector<int> turnedOn = {0, nCells+1}; // добавляем крайнии лампочки
    for (int i = 0; i < nTurnedOn; i++) { // добавляем промежуточные лампочки
        int pos; std::cin >> pos;
        turnedOn.push_back(pos);
    }
    std::sort(all(turnedOn));
    // считаем длину каждого отрезка из нулей и их суммарную длину
    // заодно считаем ответ на задачу по формуле выше
    int n = 0, answ = 1;
    for (int i = 1; i < isz(turnedOn); i++) {
        int len = turnedOn[i] - turnedOn[i-1] - 1;
        assert(len >= 0);
        n += len;
        (answ *= ifact[len]) %= mod;
        int nWays = 1;
        if (i - 1 > 0 && i + 1 < isz(turnedOn)) {
            // промежуточный отрезок, для которого 2^(len-1) способов
            nWays = binpow(2, len-1, mod);
        }
        (answ *= nWays) %= mod;
    }
    (answ *= fact[n]) %= mod;
    std::cout << answ << std::endl;
}