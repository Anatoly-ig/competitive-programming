#include <bits/stdc++.h>

int solve(int k, const std::vector<int>& a) {
// k - количество <= элементов, которые надо удовлетворить
// a - сами элементы, отсортированы в порядке неубывания
    int n = (int)a.size();
    assert(0 <= k && k <= n);
    
    if (k == 0) {
        // крайний случай - надо выбрать минимум(a) минус один
        // не забываем, что выбранное число должно быть натуральным
        // то есть не можем выбрать ноль
        return a[0] == 1 ? -1 : a[0]-1;
    }
    // в качестве ответа можно выбрать элемент из массива 'a'
    // это будет не хуже, чем элемент, который не лежит в массиве 'a'
    // перебираем каждый элемент и считаем, сколько элементов из 'a' <= ему
    // если данное число равно k, то элемент выбран (элемент подходит)
    for (auto& it : a) {
        // считаем бинпоиском сколько элементов <= it:
        // это позиция минимального элемента, который > it
        int count = int(std::upper_bound(a.begin(), a.end(), it) - a.begin());
        if (count == k)
            return it; // элемент it подходит
    }
    return -1;
}

int main() {
    std::ios_base::sync_with_stdio(false); std::cin.tie(0); std::cout.tie(0);
    
    int n, k; std::cin >> n >> k;
    
    if (n < k) {
        std::cout << "-1" << std::endl;
        return 0;
    }
    
    std::vector<int> a(n); for (auto& it : a) std::cin >> it;
    
    // сортируем массив a, так как это ничего не сломает, и позволит
    // применять бинпоиск для подсчёта числа элементов <= заданному
    std::sort(a.begin(), a.end());
    
    std::cout << solve(k, a) << std::endl;
    
    
    return 0;
}